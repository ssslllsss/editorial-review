Learn CKB From Zeroâ€” EN VERSION

*Before We Get Started*

Congratulations on opening this page!
This means you will learn everything about CKB ahead of the rest if you are a beginner.
This tutorial is your first contact with CKB, either developing a DAPP on CKB or simply understanding the basics out of curiosity.
Follow this tutorial to get your first hands-on experience with CKB.
This four-part tutorial is a complete walk-through that will allow you to figure out and implement how to

* build and send the simplest transfer transaction
* develop and send the simplest multi-signature transaction
* develop and deploy the simplest smart contract
* develop and deploy a scalable smart contract

on CKB all by yourself.
The great thing is, to figure this all out

* No need for any local downloads
* No need to run any software
* Not even to write one single line of code!

Everything will be done on this page interactively with the cloud-based test chain in a purely manual, remote way.
All you need to have is the patience for reading further down, and the curiosity for CKB. :D
No more talk then, let's start this fascinating adventure on CKB!

*Step 1: Theoretical knowledge of minimisation*

There are no bitcoins in the world, only UTXOs.
There are no CKBs in the world, just Cells.

*Unravelling the CKB*

To understand CKB, we must put aside all the complexity of the concept behind the chain and focus on the chain's very essence: everything is just a cell and the transformation of cells.
Cell is the basic unit of CKB, similar to a cell in the human body. Each cell constitutes the general state of the entire CKB blockchain. When initiating a transaction on the blockchain that changes a state, the final result for the CKB is that the transaction spends some cells and creates some new ones, regardless of the complexity of the transaction or that of the state change process. This process is the same as the Bitcoin UTXO.
The cells that have been spent are the dead cells; the unspent cells are the live cells. A chain keeps on spending cells and creating cells through transactions, like the renewal and division of cells throughout the body.
In the CKB universe, countless cells are floating around. 
Cells store data which jointly form the general state of a chain.
Unlike UTXO, a Cell can be used to store any type of data. A Cell has a field called Data inside which you can put an unformatted string. In other words, you can write whatever you want into Data, in whatever format you want, so long as you can interpret the string.
For example, I can save a hash, a text, a date, or even a piece of binary code that can be referenced by other cells and run on the chain through the virtual machine CKB-VM.
This is so called smart contract on CKB, as simple as that.

*So how can we possess a Cell?*

Cells are obtained by consensus on the chain, thus cell storage space becomes precious and owning a cell inevitably incurs costs.
And this leads us to the function of CKB's native tokens.
Imagine the Cell as a small box that can be used to carry things. The box itself is created by tokens. A box's size varies by how many tokens you have.
A box can also subdivide into multiple boxes. Simply make sure that the boxes' total space is equal to the quantity of tokens you hold.
Systematically, 1 CKB is equal to 1 byte of space.
If you have 100 CKBs, for example, you will have 100 bytes of space on the chain so you can create a box that has 100 bytes of space. You can divide the 100 bytes into as many boxes as you like, it's up to you.
Once the box (Cell) has space, it can be used to contain data which should be smaller than the size of the whole box, because the box has other components which also occupy some space.
For instance, one Chinese character accounts for 2 bytes (GBK encoding), if you have 100 CKBs, you can probably save less than 50 Chinese characters to this cell.
In the case of <Dream of the Red Chamber>, for example, the novel is about 780,000 words in total, so you will need approximately 1.56 million native CKB tokens to upload the entire book to the chain.
As you can see, Cell storage on the chain is a precious asset.
CKB is designed to store consensus only on the chain, so as to encourage everyone to upload data that is truly valuable and needs to go through consensus on the chain. Such data is comparable to a common knowledge base owned by the entire human race.
This is how the CKB got its name (Common knowledge base).
*The entire Cell data structure looks as follows:*

Cell: {

capacity: HexString

lock: Script

type: Script

data: HexString

}

These four fields have the following meanings.

* capacity: the space size of the Cell, i.e. the number of native tokens represented by this Cell, usually expressed in hexadecimal
* lock: a script, which is a lock of sorts, as detailed below.
* type: a script, same as a lock but for a different purpose, more on that below
* data: a string with no formatting, where any type of data can be kept.

More detailed descriptions of data structures can be found here: Cell data structure (https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0019-data-structures/0019-data-structures.md#Cell)
The most important rule you need to remember about Cell is that the sum of the total spaces occupied by the four fields above must be less than or equal to the value of capacity.
In other words,

           cell total space occupied = capacity

                                    >= Sum of the lengths of the 4 fields

To better understand, let's look at a concrete example.
In this small experiment, type in a Chinese character as the Cell data, and you can see the real-time changes in the length of the Cell. By clicking on the Cell, you can then see exactly the contents of the Cell, and the actual length that each field occupied.
We assume that the capacity of the Cell is 0x1dcd65000, which is 80 Bytes in size. If the change in data causes the actual capacity to grow beyond the value of capacity, the Cell will be considered invalid.

Occupancy 61 Bytes
0x

Availability of Cell capacityï¼š
capacity: 0x1dcd65000 = 80 &gt; Actual occupancyï¼š61, âœ…



*Q: How to tell if the particular Cell belongs to you? *

Since you can only possess a Cell by owning a native token, how do we know that you own a particular Cell on the chain?
Remember the lock and type mentioned above?
If the Cell is a box, the lock and type are the two locks on the box.
The lock is the default one and type is an optional one.
In essence, this lock is a piece of code and parameters.
When we try to consume a cell, the lock will automatically run and enter parameters and some proof we submit (such as a signature for the transaction) to determine if the lock can be lifted. Once unlocked, it proves that we own and control the cell.
A lock is a script structure that looks like thisï¼š

Script: {
     code_hash: HexString
     args: HexString
     hash_type: either 'data' or 'type'
     }

These three fields, hash_type is reserved for later, the other two are

* code_hash: the hash of a piece of code
* args: the arguments that will be transferred to the code.

Further details of the data structure can be foundï¼šScript data structure (https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0019-data-structures/0019-data-structures.md#Script)
The code_hash and args combined to constitute a full "lock": we locate the code to be executed by using the code_hash field and then send the argument args to this code. The code will then be executed by the virtual machine CKB-VM ( additional arguments may be read during the process, such as the proof attached to the transaction). If executed successfully, a 0 will be returned indicating that the lock can be cleared successfully; if not, other values will be returned indicating that the lock cannot be cleared.
With this principle, CKB identifies the owner of a cell, i.e. who can open the lock attached to the cell. The same principle applies to Bitcoin. 
We could implement an asymmetric encryption algorithm via code_hash and place our own public key on the args as an argument. When we need to spend the cell, for example, to initiate a transaction, we could use the private key to sign the transaction so that the cryptographic algorithm could input the public key and signature to figure out whether the transaction was initiated by the corresponding private key, thus identifying whether it was the real owner of the cell behind the operation.
If, on the other hand, you create a Cell with a lock that anyone can unlock, then everyone can spend the Cell, anyone can spend your money! This is dangerous. Locks are vital to the Cell.
**Time for a break**
Well, you have managed to read this far, so let's recap what we have learned up to now:

* The CKB chain is fundamentally a chain of Cells that are constantly being created and destroyed.
* A Cell is a box, a container, which can be used to store all types of data.
* To own a Cell, you need tokens. The number of tokens is equal to the size of the Cell. 1 CKB = 1 byte in size.
* The total size of the entire Cell cannot exceed the value of the capacity field.
* To protect your Cell, you can put a lock on the Cell that only your keys can open.

It looks like we've got a pretty good grasp of how CKB works. That's great. Trust me, you've understood most of everything. Now, we need to get into a bit more detail.

*Where is the real code hiding?*

We have learnt that the lock and type fields of the Cell can be used to lock the box, enabling us to guarantee the ownership and control of the box.
Lock is a script structure that looks like this:

  Script: {
      code_hash: HexString
      args: HexString
      hash_type: either 'data' or 'type'
  }

You may notice that the code_hash is not the actual code but a hash of the code, which is equivalent to an index of the code. This index allows us to find the actual code used by the lock. So, where is the actual code?
Simply put, the code is in another cell!
We know that the data field of the cell can contain arbitrary data, so we can put the real code in the data field of another cell and implement this cell as a dependency to a transaction. This dependency cell is called a dep cell.
When we need to unlock a cell, we can simply import the dep cell, and the CKB system will match the hash of the data in the dep cell with code_hash to find the code needed for the lock. 
So why not just put in the real code as opposed to this indexing approach?
One of the major advantages of this design is that if everyone needs the same type of lock, the lock code will be identical, and the code_hash value will be identical. Then it is just a matter of introducing the same dep cell rather than deploying the same code all over again for everyone.
Here's a real example.
The CKB system has an important built-in smart contract called SECP256K1_BLAKE160, and it is the default lock used by each Cell in the lock field during regular transfer transactions. What this lock means is that the SECP256K1 encryption algorithm serves to protect the basic ownership of each Cell. To achieve this, CKB system creates several cells during the creation of the genesis block and then puts the specific code of the SECP256K1 encryption algorithm into the data field of these cells. When the transfer is made, we include these cells in the transaction as dep cells, and fill in the code_hash with the hash of the dep cell's data field while putting our own public key hash in the args field, so the lock is capable of determining whether the signature attached to a transfer transaction is authentic and valid.
But another question may come to mind at this point.
**What if the lock code is lost?**
The code of lock is kept in another cell, what if someone has destroyed that cell? When this cell is spent, the dep cell becomes a dead cell and the code of lock will be gone. Does this mean that the cell that uses this lock no longer be able to unlock it?
Theoretically, this is true. Technically, the cell that contains the code of the lock should last as long as the chain does, and no one can access this cell.
So, as you can see by examining it, the dep cells that all the built-in lock scripts of CKB have been built on are inherently inaccessible by anyone. Because we have set the value 0x0000... in the lock field of each dep cell (i.e. the lock of the cell itself where to put the lock code), which means that no one will ever be able to unlock these cells again, and the code will always be there:

SECP256K1's lock: {
      code_hash: 0x0000000000000000000000000000000000000000000000000000000000000000
      args: 0x
      hash_type..
}          

In fact, we can still unlock our own cell if the dep_cell was destroyed, as you can just redeploy the same lock code to a new cell and then bring in the new cell as dep_cell so that you can retrieve the lock code. Because the code remains identical, therefore the hash of the code stays the same, and the value of code_hash also remains the same.
This is the additional flexibility of CKB.
These examples of locks that we talked about above were locks in the lock field from Cell.
Apart from the default lock, a Cell also has another optional type lock. These two locks are fundamentally the same, but they are given different names because of their different uses.
The "lock" lock is usually used to protect the ownership of the box, while the "type" lock is used to ensure that the Cell follows certain data transformation rules during the transaction. To understand this, we must start by understanding what a transaction in the CKB is all about.

*The transaction is to destroy some Cells and create some more.*

The essence of a transaction in the CKB, excluding the less important details, would be as followsï¼š

tx: input -> output

Where the essence of input and output is still some Cellsï¼š

 input:
      some cells...
    ï½œ
    ï½œ
    ï½œ
    \/
    output:
      some new cells...

The cells in the input must all be live cells. The input cells will be spent and become dead cells after a transaction. The newly created output cells will become new live cells.
The most important rule you need to remember about CKB transactions is that all output cells, i.e. newly created boxes, must take up less space than input cells.

 capacity(input cell) > capacity(output cell)

Why less? Because the difference, or the extra space, between input and output is the fee that the miner earns. Miners can't work for nothing, of course.
In practice, we do not really put the full cell in the input for storage optimization purposes, instead we just put the index of the cell and use the index to find the cell used as input. This index structure is called OutPoint, which allows you to find the unique cell.

OutPoint: {
      tx_hash: Hash value of the affiliated transaction(to which transaction it belongs)
      index: Serial number of the affiliated transaction output(to which output it belongs)
    }

*Role of the "type lock"*

As cells are transformed from inputs to outputs in a transaction, the transformation process can be guided by certain user-defined rules.
For example, I want a cell to produce only one new cell at a time in a transaction, I can make such a rule into a lock on the box.
Another example, I would like a cell to never show the word "carrot" in its data field during a transaction, I could create a lock with such a rule, which would be added as a type lock to the box.
This is the distinction between "type" locks and "lock locks. One protects the ownership of the box and the other secures the data transformation rules. The "lock" lock is the gatekeeper of the cell, while the "type" lock is the guardian of the cell. This variance in use comes down to the difference in the design of the two locks in terms of their operating mechanism.
Operational mechanisms of the two locks:

* "lock" locks: Within a transaction, the " lock" locks for all inputs will be executed once.
* "type" locks: In a transaction, the " type" locks of all inputs and outputs will be executed once.

As the execution mechanism varies, so does the appropriate usage. Of course, you can have your own thoughts on this, but essentially these usages are simply the recommended official usage. You are free to disregard them.

*Take some rest.*

Congratulations! You now have the bare minimum basics necessary for this tutorial!
Let's review all the concepts we have learned:

* CKB is essentially a chain of cells that are being created and destroyed over and over again.
* Cell is a box, a container, which can be used to contain any type of data.
* To possess a Cell, you need to have tokens. The amount of tokens equals the size of the box. 1 CKB = 1 byte in size.
* The total space occupied by the entire Cell cannot exceed the value of the capacity field.
* To protect your Cell, you can put a lock on the Cell box that only your own key can unlock.
* The lock is essentially a piece of code that can be run and some arguments. By entering the arguments and some signature or proof provided by the user, the code runs to check if the lock can be opened.
* The return value of 0 means that the lock was unlocked successfully, while any other value means unlock failed.
* Cell locates the code for the lock by the code_hash, these codes are saved in the data field of the dep cell.
* Each Cell can carry two locks, one called lock (default) and one called type (optional).
* In one transaction, the "lock" lock of all inputs will be executed once.
* In one transaction, the " type " locks for both inputs and outputs will be executed once.
* The differences in the operational mechanism result in different uses for the two locks.
* The "lock" lock is often used to protect the ownership of the box.
* The type lock is usually used to ensure that the box's data conversion rules are followed.
* A transaction is fundamentally about destroying some cells and creating some new ones.

That's right, with the above theoretical knowledge, you're ready to hit the road.
Up next, we'll have a hands-on experience with the CKB!

*Step 2ï¼šGet your hands dirty*

You can get a better understanding of theoretical knowledge by getting hands-on experience with the CKB chain.


We have already been running a test chain over the cloud and have pre-generated some account addresses for this tutorial. Try clicking on the button below to check out the latest blocks in the chain.
 

Fetch Blocks 

We have prepared 3 wallets.
Try hovering over the wallets to open them.


â˜ ï¸ For demonstration use only. Do not use these wallets in formal situations or under the main network.
wallet 1.....
wallet 2.....
wallet 3.....

Each wallet carries four messages, meant as follows:

mainnet, indicates the primary network address of the wallet.
testnet, indicates the testing network address of the wallet. In this tutorial, we will only use the testnet address.
lock_arg, indicates the first 20 bits of the wallet's corresponding public key hash. Think of it simply as a fingerprint of the public key.
private_key, is the private key of the wallet.

You should not expose it as I did. In this tutorial, these 3 wallets will be used to send transactions, deploy contracts and various other purposes.
Now, you can select any of these wallets to review the Cell and transactions associated with this wallet by clicking on the button below.

Please select a wallet

Click on any of the above cells or transactions for details in JSON format.
By saying how many CKBs (native tokens) a wallet has, we actually refer to the sum of the capacity of all the live cells the wallet had unlocked, i. e. the total storage the wallet had on the chain.
Now, Wallet 1 serves as the default miner address for this beta chain on the cloud. In other words, Wallet 1 will constantly receive block rewards generated by mining. As a result, you will see that Wallet 1 has found the most live cells, while Wallets 2 and 3 have very few, if any, live cells.  
Currently, there is only one miner on the test chain.
At last, we also need to know the configuration information for this testing chain.

Configuration information for the testing chain

{
  "PREFIX": "ckt",
  "SCRIPTS": {
    "SECP256K1_BLAKE160": {
      "CODE_HASH": "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8",
      "HASH_TYPE": "type",
      "TX_HASH": "0x4f1097802dc6fe19b942f1c2e8e52d564ee35899e4aef308101c86c49bc1f471",
      "INDEX": "0x0",
      "DEP_TYPE": "dep_group",
      "SHORT_ID": 0
    },
    "SECP256K1_BLAKE160_MULTISIG": {
      "CODE_HASH": "0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8",
      "HASH_TYPE": "type",
      "TX_HASH": "0x4f1097802dc6fe19b942f1c2e8e52d564ee35899e4aef308101c86c49bc1f471",
      "INDEX": "0x1",
      "DEP_TYPE": "dep_group",
      "SHORT_ID": 1
    },
    "DAO": {
      "CODE_HASH": "0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e",
      "HASH_TYPE": "type",
      "TX_HASH": "0x075c01b717840fd37fcf4a2f1b1bcdbf7c26f9c4781855bb772ac9d1a57eb2f0",
      "INDEX": "0x2",
      "DEP_TYPE": "code"
    }
  }
}

*prefix: ckt* represents that the chain is a beta chain rather than the main network.
*scripts* represent the built-in smart contracts of the chain, i.e. some of the system's built-in locks that type and lock can use.

Each CKB chain will pre-deploy several built-in smart contracts in the Genesis block, which displays the specific information of the three system contracts.

* SECP256K1_BLAKE160ï¼šthe system's default contract for the "lock" lock of the Cell, used to protect the ownership of the Cell
* SECP256K1_BLAKE160_MULTISIGï¼šthe multi-signature version of SECP256K1_BLAKE160
* DAOï¼šNervosDAO contract, can be ignored on a temporary basis

These are all the information we must know.
Next, we'll commence building and sending our first transaction!

*Sending A Transaction*

In this section, we will have a hands-on lesson on how to complete a very basic transfer transaction.
A quick refresher before we start:
A CKB transaction is nothing more than spending some existing live cells and creating some new ones.

Since CKB is designed as " off-chain computing, on-chain confirming", it is possible for us to complete a transfer operation by collaging transactions manually.
As long as we draw up the content of the transaction in advance (i.e., which cells will be spent and which new cells will be created), then sign the transaction with the corresponding private key. Once the transaction is submitted to the chain, validated and signed in a valid manner, then the transaction will be packed and executed.

What does such a manual collage of transactions mean?

åœ¨ CKB è¿™ç§ä½“ç³»ä¸‹ï¼Œå…¶å®æˆ‘ä»¬äººè‚‰ç»„æˆäº†ä¸€ä¸ª layer2 ç½‘ç»œã€‚
We actually compose a layer2 network under a system like CKB.

æƒ³è±¡ç°åœ¨ä½ æœ‰ä¸€ä½æœ‹å‹ä½åœ¨äºšé©¬é€Šä¸›æ—é‡Œï¼Œä»–ç‹¬è‡ªç”Ÿæ´»ï¼Œèº«è¾¹åªæœ‰ä¸€å°ç¦»çº¿çš„ç”µè„‘ï¼Œæ²¡æœ‰ç½‘ç»œï¼Œä¸ä¸–éš”ç»ã€‚
Pretend you have a friend now living in the Amazon jungle, isolated with nothing but an offline computer next to him.
æŸå¤©ä¸‹åˆä»–æ‰“çŒå½’æ¥ï¼Œçªç„¶æƒ³èµ·æ¥è¿˜æ¬ ä½ ä¸€ç‚¹é’±ï¼Œä»–æ‰“å¼€ç”µè„‘ï¼Œæƒ³è½¬ç»™ä½  1 ä¸‡ä¸ª CKB è¿˜å€ºã€‚
å°½ç®¡æ²¡æœ‰ç½‘ç»œï¼Œä»–è¿˜æ˜¯æŠŠè½¬è´¦äº¤æ˜“çš„å†…å®¹å†™åœ¨äº†ä¸€å¼ çº¸ä¸Šï¼Œç„¶ååœ¨ç”µè„‘é‡Œè¾“å…¥è‡ªå·±çš„ç§é’¥ï¼Œè®¡ç®—å‡ºäº†è¿™ç¬”è½¬è´¦ç›¸åº”çš„ç­¾åï¼Œæœ€åæŠŠç­¾åä¹Ÿé™„åœ¨äº†çº¸ä¸Šã€‚
Then, one afternoon, he returned home from a hunting trip and suddenly remembered that he still has some money owed to you. So he turned on his computer and attempted to transfer 10,000 CKBs to you to settle his debt.
Despite no internet access, he wrote down the contents of the transfer transaction on a piece of paper, then entered his private key into the computer, calculated the corresponding signature for the transfer, and then signed the paper with his signature.
è¿‡äº†åŠä¸ªæœˆï¼Œå½“æœ‰ä¿¡å·®æ¥è®¿æ—¶ï¼Œä»–æ‰˜äººæŠŠè¿™å¼ çº¸é‚®å¯„åˆ°ä¸­å›½ï¼Œåˆè¿‡äº†åŠä¸ªæœˆï¼Œä¿¡çº¸ç»ˆäºé€åˆ°äº†ä½ çš„æ‰‹ä¸Šã€‚
Half a month later, when the courier visited, he asked to send this paper to China by mail. Another half month later, the paper finally reached you.
ä½ çœ‹ç€ä¿¡çº¸ï¼Œäº¤æ˜“ç¡®å®æŒ‡æ˜åˆ›é€  1 ä¸‡ CKB çš„ cell ç»™ä½ ï¼Œä½ å†³å®šæŠŠè¿™ç¬”äº¤æ˜“æäº¤åˆ° CKB ä¸»ç½‘ä¸Šã€‚ 
You looked at the paper, the transaction did specify the creation of 10,000 CKB cells to you, and you decided to submit the transaction to the CKB mainnet.
ä¸»ç½‘éªŒè¯é™„ä¸Šçš„ç­¾åæœ‰æ•ˆï¼Œäºæ˜¯äº¤æ˜“å®Œæˆï¼Œä½ çš„è´¦æˆ·é‡Œå¤šäº†ä¸€ä¸‡ä¸ªCKBï¼Œå€ºåŠ¡ä¸¤æ¸…äº†ã€‚
The mainnet validated the attached signature, the transaction has completed, leaving you with 10,000 more CKBs in your account. The debt is cleared.
ä½ å’Œäºšé©¬é€Šä¸›æ—çš„æœ‹å‹å…±åŒç»„æˆäº†ä¸€ä¸ªåŒ…å« 2 ä¸ªèŠ‚ç‚¹çš„ layer2 ç½‘ç»œï¼Œè™½ç„¶è¿™ä¸ªç½‘ç»œçš„ååé‡åªæœ‰ 1 ç¬”äº¤æ˜“/æ¯æœˆã€‚
In the process, you and your jungle buddy at Amazon have created a layer2 network with 2 nodes, only this network has a throughput of 1 transaction/month.
å°½ç®¡ CKB ç›®å‰å·²ç»æœ‰äº†å„ç§å„æ ·çš„å·¥å…·ï¼Œå¸®åŠ©ä½ è‡ªåŠ¨æ„å»ºäº¤æ˜“ã€å®Œæˆè½¬è´¦ã€éƒ¨ç½²åˆçº¦ï¼Œç­‰ç­‰ï¼Œ ä½†æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è¿˜æ˜¯ä¼šå»¶ç»­äºšé©¬é€Šæœ‹å‹çš„è¿™ç§æ–¹æ³•ï¼Œæ¥å®ç°ä¸€ç¬”æ™®é€šçš„è½¬è´¦äº¤æ˜“ã€‚
CKB now has a variety of tools to help you auto-build transactions, transfer and deploy contracts, etc. However, we'll stick with this approach of our friends from Amazon to implement a regular transfer transaction.
ç›®çš„æ˜¯ä½¿ç”¨æ‰‹åŠ¨æ‹¼æ¥äº¤æ˜“çš„æ–¹å¼ï¼Œè®©ä½ æ›´æ·±åˆ»çš„ç†è§£ CKB cell çš„å·¥ä½œåŸç†ã€‚
This is intended to give you a deeper insight into how the CKB cell works by using manually assembled transactions.
æˆ‘ä»¬å°†ä½¿ç”¨ JSON æ ¼å¼æ¥æ‰‹åŠ¨æ‹¼æ¥äº¤æ˜“ã€‚
We will use the JSON format to assemble the transactions manually.

*äº¤æ˜“çš„ INPUT  Input of Transactions*

ä¸‹é¢æ˜¯é’±åŒ… 1 çš„ 4 ä¸ª live cellï¼Œç›´æ¥æŠŠ cell æ‹–åˆ°ä¸‹é¢çš„æ¡†ä¸­ï¼Œçœ‹çœ‹è‡ªåŠ¨ç”Ÿæˆçš„ input æ˜¯ä»€ä¹ˆæ ·å­çš„ã€‚
Below are the 4 live cells from wallet 1. Drag the cells directly into the box underneath to see how the automatically generated input looks like.
ä½ å¯èƒ½çœ‹åˆ°äº†ï¼Œinput ä¸­çš„ cell æ˜¯ä»¥ previous_output çš„å½¢å¼å‡ºç°çš„ï¼Œ ä¼ å…¥çš„æ˜¯ tx_hash å’Œ index ç»„æˆçš„ outpointï¼Œç›¸å½“äºæ˜¯å¯¹ cell çš„ä¸€ä¸ªç´¢å¼•ï¼Œæˆ–è€…åƒ cell çš„ä¸€ä¸ªæŒ‡é’ˆï¼Œé€šè¿‡ outpoint æˆ‘ä»¬æ‰¾åˆ°æƒ³è¦æ¶ˆè´¹çš„ cellã€‚
You probably noticed that the cell in input appears under the form of previous_output, which is imported as an outpoint that composed of tx_hash and index, comparable to an index of the cell, or a pointer to the cell, by which we could locate the cell we want to spend.
inputs ä¸­è¿˜æœ‰ä¸€ä¸ªå­—æ®µå« sinceï¼Œå®ƒæ˜¯ç”¨æ¥æ§åˆ¶æ—¶é—´çš„ï¼Œæˆ‘ä»¬æš‚ä¸”ä¸å¿…ç®¡å®ƒã€‚
In the inputs, there is another field called since, which controls the time. Don't bother with it for now.
é™¤äº†inputsï¼Œè¿˜æœ‰ä¸€ä¸ªå­—æ®µå« cell_depsï¼Œå®ƒæ˜¯ä¸€ç¬”äº¤æ˜“ä¸­éœ€è¦ä¾èµ–çš„ cellï¼Œ ä¹Ÿæ˜¯ä»¥ outpoint è¿™ç§ç´¢å¼•ç»“æœå‡ºç°çš„ã€‚
Other than inputs, there is also a field called cell_deps, which is the cell that needs dep_cell in a transaction also appearing as an index result of outpoint.
ä»€ä¹ˆæ˜¯éœ€è¦ä¾èµ–çš„ cell å‘¢ï¼Ÿ
what is dep_cell?
æ¯”å¦‚åœ¨æ™®é€šçš„è½¬è´¦äº¤æ˜“ä¸­ï¼Œlock é”éœ€è¦ç”¨åˆ°å›ºå®šçš„åŠ å¯†ç®—æ³• SECP256K1_BLAKE160ï¼Œä¹Ÿå°±æ˜¯ç³»ç»Ÿå†…ç½®çš„ä¸€ä¸ªæ™ºèƒ½åˆçº¦ï¼Œ è¿™ä¸ªåŠ å¯†ç®—æ³•çš„ä»£ç å­˜æ”¾åœ¨æŸä¸ª cell ä¸­ï¼Œå°±éœ€è¦åœ¨ cell_deps ä¸­å¼•ç”¨è¿›æ¥ï¼Œ è¿™æ · CKB-VM è™šæ‹Ÿæœºæ‰èƒ½çŸ¥é“ä»å“ªé‡Œè½½å…¥ä»£ç è¿›è¡Œè¿ç®—ã€‚
é€šè¿‡ä¸Šæ–‡æµ‹è¯•é“¾çš„é…ç½®ä¿¡æ¯ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“æ‰¾åˆ° cell_deps ä¸­éœ€è¦ä¼ å…¥çš„å‚æ•°ã€‚
For instance, in a regular transfer transaction, the "lock" lock requires a fixed encryption algorithm, SECP256K1_BLAKE160, a built-in smart contract.
The code of this encryption algorithm is kept in a cell and needs to be referenced in cell_deps so that the CKB-VM virtual machine would know where to import the code for calculation.
We can easily find the arguments we need to send in cell_deps by looking at the configuration information of the test chain above.

*äº¤æ˜“çš„ OUTPUT Output of Transactions*

æ¥ä¸‹æ¥æˆ‘ä»¬å†ä½¿ç”¨å¦ä¸€ä¸ªå·¥å…·ï¼Œçœ‹çœ‹ç”Ÿæˆçš„outputã€ä»¥åŠä¸€ç¬”å®Œæ•´çš„äº¤æ˜“é•¿ä»€ä¹ˆæ ·å­ã€‚
Next, let's use another tool to see how the output generated and the complete transaction look like. 
åŒæ ·ï¼ŒæŠŠé’±åŒ… 1 çš„ cell æ‹–åˆ° input ä¸­ã€‚
Again, drag the cell from Wallet 1 to the input. 
output æ–¹æ¡†å†…å°†é©¬ä¸Šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªç›¸åŒå¤§å°çš„æ–° cellã€‚
A new cell with an identical size will be automatically generated in the output. 
ç‚¹å‡» output ä¸­çš„è®¾ç½®æŒ‰é’®ï¼Œå¯ä»¥å¯¹æ–°ç”Ÿæˆçš„ cell è¿›è¡Œé‡æ–°åˆ†é…ï¼ŒåŒ…æ‹¬ç”Ÿæˆå‡ ä¸ª cellã€è®¾ç½®æ¯ä¸ªæ–° cell çš„å¤§å°ï¼Œè®¾ç½®æ¯ä¸ª cell çš„è§£é”åœ°å€ï¼Œç­‰ç­‰ã€‚
Click the settings button in output to reassign the newly generated cells, including specifying how many cells to generate, setting the size of each new cell, defining the unlock address for each cell, etc.
output å ç”¨çš„ capacity ç©ºé—´å¿…é¡»å°äº inputï¼ŒäºŒè€…çš„å·®å€¼å³ä¸ºçŸ¿å·¥èƒ½æŒ£åˆ°çš„æ‰‹ç»­è´¹ã€‚
è®¾ç½®å®Œæˆåï¼Œç‚¹å‡»â€œç”Ÿæˆäº¤æ˜“â€çš„æŒ‰é’®ï¼Œå°±å¯ä»¥çœ‹åˆ°è¿™ç¬”äº¤æ˜“çš„ JSON æ˜¯ä»€ä¹ˆæ ·å­äº†ã€‚
The output must take up less capacity than the input, and the difference between the two is the fee the miner will earn.
After setting it up, click the " Generate Transaction" button to see the JSON of the transaction.
é’±åŒ…1çš„cell Cell for wallet 1
æŠŠcellæ‹–è¿›è¿™é‡Œï¼Œæ€»ç©ºé—´ï¼Œè®¾ç½®ï¼ŒçŸ¿å·¥æ‰‹ç»­è´¹Drag cell in here, total space, settings, miner fees
ç”Ÿæˆä¸€ç¬”äº¤æ˜“ï¼Œæ¸…ç©ºGenerate a transaction, flush it out
ä½ åº”è¯¥æ³¨æ„åˆ°äº†ï¼Œäº¤æ˜“ä¸­çš„ outputsæŠŠæ–°ç”Ÿæˆçš„ cell çš„ä¿¡æ¯éƒ½å†™å‡ºæ¥äº†ï¼ŒåŒ…æ‹¬ capactiy å¤§å°ã€lock é”ç­‰ä¿¡æ¯ã€‚
You may have noticed that the outputs of the transaction have all the information about the newly generated cell written out, including capactiy size, lock lock, etc.
ä½† output ä¸­çš„ cell å¹¶æ²¡æœ‰æŒ‡æ˜ data çš„ä¿¡æ¯ï¼Œç›¸åï¼Œdata è¢«ç»Ÿä¸€æŒªåˆ°äº†outputs_data å­—æ®µä¸­ï¼ŒæŒ‰é¡ºåºå¯¹åº” outputs ä¸­çš„ cellã€‚
è¿™æ ·åšä¹Ÿæ˜¯å‡ºäºæ€§èƒ½ä¼˜åŒ–è§’åº¦æ¥è®¾è®¡çš„ã€‚
The cell in the outputs does not specify the data, instead the data is moved to the outputs_data field, which corresponds to the cells in the outputs sequentially. Again, this is designed for performance optimisation.
æœ€åï¼Œä¸€ç¬”å®Œæ•´çš„äº¤æ˜“è¿˜åŒ…æ‹¬ version å’Œ header_deps ä¸¤ä¸ªå­—æ®µã€‚ å‰è€…ä¸ºç‰ˆæœ¬ä¿¡æ¯ï¼Œç›®å‰å›ºå®šè®¾ç½®ä¸º 0x0 ï¼Œåè€…æš‚æ—¶ä¸ç”¨ç®¡ï¼Œæ”¾ç©ºå°±è¡Œã€‚
A complete transaction also includes two fields, version and header_deps. The former is the version information, which is currently fixed at 0x0, while the latter is left blank for now.

*å¯¹äº¤æ˜“è¿›è¡Œç­¾å Signing the transaction*

ä¸€ç¬”è½¬è´¦æ‹¼å¥½ä¹‹åï¼Œéœ€è¦ç”¨ç›¸åº”çš„ç§é’¥ï¼Œå¯¹è¿™ç¬”äº¤æ˜“è¿›è¡Œç­¾åï¼Œè¡¨æ˜æˆ‘ä»¬ç¡®å®æ˜¯ cell çš„ä¸»äººï¼Œæœ‰æƒå¯¹è¿™äº› cell æ‰§è¡Œæ“ä½œã€‚
Once a transaction has been assembled, a private key needs to be assigned to sign the transaction, indicating that we are truly the owner of the cells and are entitled to perform operations on them.
ç­¾åå°†è¢«æ”¾å…¥ä¸€ä¸ªæ–°çš„åä¸º witnesses çš„å­—æ®µä¸­ï¼Œä½œä¸ºäº¤æ˜“çš„è¯æ˜ã€‚
The signature will then be put into a new field called witnesses, which serves as proof of the transaction.
åˆ°è¿™é‡Œä½ å·²ç»å®Œæ•´äº†è§£äº†ä¸€ç¬”äº¤æ˜“çš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬é©¬ä¸Šå¼€å§‹åŠ¨æ‰‹å‘äº¤æ˜“ã€‚
Now you have a complete understanding of how a transaction works, let's get down to the business of sending transactions.
ç°åœ¨ï¼ŒæŠŠä¸‹é¢ç™½æ¡†ä¸­çš„ç©ºç™½äº¤æ˜“å¡«æ»¡ã€‚Now, complete the blank transaction shown in the white box below.
æŠŠå®ƒå½“ä½œä¸€æ¬¡ç»ƒä¹ ï¼Œè‡ªå·±ç”¨æ‰‹åŠ¨çš„æ–¹å¼å¡«å†™ä¸€ç¬”è½¬è´¦äº¤æ˜“ã€‚Use this as an exercise to complete a transfer transaction on your own hand.
ä½ å¯èƒ½éœ€è¦ç”¨åˆ°æŸ¥æ‰¾é’±åŒ…å¯¹åº”çš„ live Cellã€æŸ¥çœ‹é“¾é…ç½®ä¿¡æ¯(ç”¨æ¥å¡«å†™ cell_deps)ã€16 è¿›åˆ¶ä¸ 10 è¿›åˆ¶äº’ç›¸è½¬æ¢è¿™äº›åŠŸèƒ½ï¼Œå®ƒä»¬åœ¨å³æ‰‹è¾¹çš„å·¥å…·ç®±ä¸­éƒ½å¯ä»¥æ‰¾åˆ°ã€‚
You may need to use the functions to locate the live cell corresponding to your wallet, to view the chain config info (to fill in cell_deps) and to convert from hex to decimal etc., all of which can be found in the toolbox on the right hand side.
ç‚¹å‡»å³è¾¹ ğŸ‘‰ Nervos çš„ logoï¼Œå³å¯æ‰“å¼€å·¥å…·ç®±ã€‚
Click on the ğŸ‘‰ Nervos logo to the right to open the toolbox.

*å°†ä¸‹é¢çš„äº¤æ˜“è¡¥å……å®Œæˆ Complete the following transaction*

{
      version: "0x0",
      cell_deps: [
        {
          out_point: {
            tx_hash: "Fill in the blanks here",
            index: "Fill in the blanks here",
          },
          dep_type: "Fill in the blanks here", 
        },
      ],
      header_deps: [],
      inputs: [
        {
          since: "0x0",
          previous_output: {
            tx_hash: "Fill in the blanks here",
            index: "Fill in the blanks here",
          },
        },
      ],
      outputs: [
        {
          capacity: "Fill in the blanks here",
          lock: {
            code_hash: "Fill in the blanks here",
            hash_type: "Fill in the blanks here",
            args: "Fill in the blanks here",
          },
        },
      ],
      outputs_data: ["0x"],
      witnesses: ["0x"]
}

å¡«å†™å®Œæˆåï¼Œç‚¹å‡»ä¿å­˜æŒ‰é’®ã€‚Click on the Save button after filling it out.
å¥½äº†ï¼Œåˆ°è¿™é‡Œä½ å·²ç»æ‰‹åŠ¨æŠŠäº¤æ˜“å…¨éƒ¨å¡«å¥½äº†ã€‚Well, by now you have filled in all the transactions manually.
è¿™æ—¶æˆ‘ä»¬å·²ç»å¯ä»¥ä¸ºè¿™ç¬”äº¤æ˜“ç”Ÿæˆä¸€ä¸ªç‹¬ä¸€æ— äºŒçš„å“ˆå¸Œäº†ï¼Œä¹Ÿå°±æ˜¯ tx_hash å·²ç»å¯ä»¥æå‰ç¡®å®šå‡ºæ¥ã€‚We can now generate a unique hash for the transaction, the tx_hash has already been generated beforehand.
ç‚¹å‡»ä¸‹é¢çš„æŒ‰é’®ï¼Œè¯•è¯•ç”Ÿæˆç”Ÿæˆäº¤æ˜“çš„å“ˆå¸Œã€‚Click the button below and try generating the hash used to generate the transaction.

Generate tx_hash

å°½ç®¡è¿™ç¬”äº¤æ˜“å·²ç»å¯ä»¥æå‰ç”Ÿæˆ tx_hashï¼Œä½†å®ƒç°åœ¨ä»ç„¶æ˜¯ä¸€ç¬” raw_txã€‚raw_tx è·Ÿ tx æœ€å¤§çš„ä¸åŒæ˜¯ï¼Œ tx ä¼šåœ¨ witnesses å­—æ®µä¸­æ”¾å…¥äº¤æ˜“çš„ç­¾åã€‚
While the transaction has been able to generate a tx_hash upfront, the transaction is still a raw_tx. raw_tx differs from tx in that tx puts the signature of the transaction in the witnesses field.
äº‹å®ä¸Šï¼Œä½ å¯ä»¥åœ¨ witnesses é‡Œæ”¾å…¥ä»»ä½•ä½ éœ€è¦çš„å‚æ•°æˆ–è€…è¯æ˜ã€‚è€Œä¸”å› ä¸ºå®ƒæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œè¿˜å¯ä»¥æ”¾å…¥å¤šä¸ªè¯æ˜ã€‚ ä½†å› ä¸ºç°åœ¨æˆ‘ä»¬åœ¨å°è¯•çš„æ˜¯ç³»ç»Ÿå†…å»ºçš„è½¬è´¦äº¤æ˜“ï¼Œ è¿™ç§äº¤æ˜“äº’ç›¸çº¦å®šä¼šåœ¨æ¯ä¸€ç»„ witnesses çš„ç¬¬ä¸€ä¸ªä½ç½®ï¼Œæ”¾å…¥è¿™æ ·ä¸€ä¸ªç»“æ„ï¼š
In fact, you can put any arguments or proofs you need in witnesses. Also, being an array, it is possible to put in multiple witnesses. Since we are now talking about a system-built transaction, the mutual agreement will be to put a structure in the initial field of each set of witnesses, such as:

{
  "lock": "è¯æ˜",
  "input_type": "è¯æ˜",
  "output_type": "è¯æ˜"
}

è¿™ä¸€ä¸ªç»“æ„è¢«ç§°ä¸º WitnessArgsã€‚ä¸åŒçš„é”ä¼šä» WitnessArgs ä¸åŒçš„å­—æ®µä¸­è¯»å–è‡ªå·±éœ€è¦çš„ç­¾åã€‚ å…¶ä¸­ï¼Œlock å­—æ®µæ˜¯ input ä½¿ç”¨åˆ°çš„ lock é”éœ€è¦éªŒè¯çš„ç­¾åã€‚ åœ¨æˆ‘ä»¬ç°åœ¨è¦å®éªŒçš„æ™®é€šè½¬è´¦äº¤æ˜“ä¸­ï¼Œå°±æ˜¯ SECP256K1_BLAKE160 ç®—æ³•éœ€è¦éªŒè¯çš„ç­¾åã€‚
input_type å’Œ output_type åˆ™æ˜¯ input å’Œ output ä¸­ type é”éœ€è¦éªŒè¯çš„ç­¾åï¼Œæš‚æ—¶ä¸å¿…ç®¡å®ƒã€‚
This structure is called WitnessArgs. Different locks retrieve each signature required from the different fields of WitnessArgs.The lock field is the signature that needs to be verified for the lock that the input will use. In our case, this is the signature required by the SECP256K1_BLAKE160 algorithm to be verified. 
The input_type and output_type fields are the signatures required for the type locks in input and output, let's ignore them for now.
ç­¾åæ˜¯ä¸€ä¸ªæ¯”è¾ƒç¹ççš„è¿‡ç¨‹ã€‚æ›´è¯¦ç»†çš„æŠ€æœ¯ç»†èŠ‚åœ¨è¿™é‡Œï¼šHow to sign transaction (https://github.com/nervosnetwork/ckb-system-scripts/wiki/How-to-sign-transaction)
ç°åœ¨ï¼Œä¸ºäº†å®Œæˆç­¾åï¼Œè®©æˆ‘ä»¬é¦–å…ˆä¸ºè¿™ç¬”äº¤æ˜“ç”Ÿæˆä¸€ä¸ªå¾…ç­¾åçš„ messageã€‚
Signature is a tedious one. More technical details can be found here: How to sign transaction (https://github.com/nervosnetwork/ckb-system-scripts/wiki/How-to-sign-transaction)
Now, let's start by generating a message to be signed for this transaction in order to complete the signature.

generate message

*å¼€å§‹ç­¾å Start signing*

æœ‰äº† messageï¼Œä»¥åŠé’±åŒ…é‡Œçš„ç§é’¥ï¼Œæˆ‘ä»¬å°±å¯ä»¥è®¡ç®—å‡ºç­¾åäº†ã€‚
Once we have the message and the private key of our wallet, we can calculate the signature.

*æŠŠç­¾åæ”¾å›åˆ°äº¤æ˜“ä¸­ Put the signature back into the transaction*

æŠŠç”Ÿæˆçš„ç­¾åå¡«å…¥ä¸‹é¢çš„è¾“å…¥æ¡†ä¸­ï¼Œç‚¹å‡»æŒ‰é’®ï¼Œä»¥ witnessArgs çš„å½¢å¼åšä¸€éåºåˆ—åŒ–ï¼š
Fill in the following input box with the generated signature and click on the button to serialise as witnessArgs all over again.

serialise witenessArgs


ç°åœ¨æˆ‘ä»¬å¯ä»¥å®Œå–„åŸæœ¬çš„äº¤æ˜“äº†ï¼ŒæŠŠåºåˆ—åŒ–å¥½çš„ç­¾åæ”¾è¿› witnesses å­—æ®µé‡Œï¼š
Now we can finalise the original transaction by putting the serialised signature into the witnesses field:

*æœ€åä¸€æ­¥ï¼ŒæŠŠäº¤æ˜“å‘é€åˆ°é“¾ä¸Š Final step, send the transaction on chain*

å‘é€äº¤æ˜“ Send the transaction
æ³¨æ„çœ‹ä¸‹ï¼Œäº¤æ˜“æˆåŠŸä¸Šé“¾åè¿”å›çš„ tx_hashï¼Œæ˜¯ä¸æ˜¯å’Œä¹‹å‰äº‹å…ˆç”Ÿæˆçš„é‚£ä¸ª tx_hash ä¸€æ¨¡ä¸€æ ·ï¼Ÿ
Note that the tx_hash returned after the transaction has been successfully sent on chain is exactly the same as the tx_hash generated beforehand.
CKB çš„ç¡®å®šæ€§è¯šä¸æ¬ºæˆ‘ã€‚The certainty of CKB does not lie.
ç°åœ¨ï¼Œä½ å¯ä»¥é€šè¿‡ä¸‹é¢çš„æŒ‰é’®ï¼Œçœ‹çœ‹åˆšæ‰æˆ‘ä»¬å‘é€çš„äº¤æ˜“æ˜¯ä¸æ˜¯çœŸçš„åœ¨é“¾ä¸Šäº†ã€‚å¦‚æœæç¤º tx_status: pending , åˆ™è¡¨æ˜äº¤æ˜“è¿˜åœ¨pendingï¼Œç¨åé‡è¯•å°±å¯ä»¥äº†ã€‚
Now, you can use the button below to see if the transaction we just sent is actually on chain. If it says tx_status: pending, then the transaction is still pending, just retry later.
æŸ¥çœ‹æ‰“åŒ…äº†è¯¥äº¤æ˜“çš„åŒºå—
Check the block where the transaction was packaged
æœ€åæ­å–œä½ ï¼ŒæˆåŠŸå®Œæˆäº†ç¬¬ä¸€å°èŠ‚çš„å†…å®¹ï½
Congratulations on successfully completing the first section!
æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†ä¼šå­¦ä¹ å¦‚ä½•å‘é€ä¸€ç¬”å¤šç­¾çš„è½¬è´¦äº¤æ˜“ã€‚
We will then learn how to send a multi-signature transfer transaction.
æ›´å¤šè¯¾ç¨‹

*å‘é€å¤šç­¾äº¤æ˜“*

æ•¬è¯·æœŸå¾…ã€‚

*éƒ¨ç½²ä¸€ä¸ªåˆçº¦*

æ•¬è¯·æœŸå¾…ã€‚

*éƒ¨ç½²ä¸€ä¸ªå¯å‡çº§çš„åˆçº¦*

æ•¬è¯·æœŸå¾…ã€‚
 
